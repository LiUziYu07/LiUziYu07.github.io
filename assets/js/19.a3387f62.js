(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{426:function(t,e,l){"use strict";l.r(e);var s=l(2),r=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"双指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双指针"}},[t._v("#")]),t._v(" 双指针")]),t._v(" "),e("h3",{attrs:{id:"detect-circle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#detect-circle"}},[t._v("#")]),t._v(" Detect circle")]),t._v(" "),e("h4",{attrs:{id:"floyd-s-cycle-finding-algorithm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#floyd-s-cycle-finding-algorithm"}},[t._v("#")]),t._v(" Floyd’s Cycle-Finding Algorithm")]),t._v(" "),e("ol",[e("li",[t._v("使用一个快指针（step == 2），一个慢指针（step == 1），从链表的头开始出发")]),t._v(" "),e("li",[t._v("如果二者相遇（一定存在环），则将慢指针设置在链表头，快指针保持不动")]),t._v(" "),e("li",[t._v("二者再次相遇位置就是环的起点")])]),t._v(" "),e("h2",{attrs:{id:"反转连续链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反转连续链表"}},[t._v("#")]),t._v(" 反转连续链表")]),t._v(" "),e("p",[t._v("不使用栈，仅遍历一次列表的方法")]),t._v(" "),e("p",[t._v("![reversed link listed](D:\\lzyblog\\source\\reversed link listed.jpg)")]),t._v(" "),e("p",[t._v("算法的基本思想是：")]),t._v(" "),e("ol",[e("li",[t._v("计算围绕列表中的三个元素展开，每次让最右侧元素移动到最左边，其余元素右移")]),t._v(" "),e("li",[t._v("中间的元素（B）不动，仅改变其next指针指向的元素，新指向的元素就是下一个被提前的元素（E）")]),t._v(" "),e("li",[t._v("最右侧的元素（C或者D）的next指针指向最左侧元素（B或者C）")]),t._v(" "),e("li",[t._v("最后不动的元素（A）指向需要被移动过来的元素（D）")]),t._v(" "),e("li",[t._v("重复2~3")])])])}),[],!1,null,null,null);e.default=r.exports}}]);